Thought for 4 seconds
Below is a “production-safe” main.py that works both:

Locally – python main.py still launches the dev server on port 5000

On Render / any PaaS – gunicorn just imports app from main, so nothing extra runs

python
Copy
Edit
# main.py
from flask import Flask, request, jsonify, render_template
from flask_cors import CORS
from dotenv import load_dotenv
import os, requests

load_dotenv()                       # ⬅️ picks up GROQ_API_KEY, etc.

app = Flask(__name__)
CORS(app)

print("Loaded GROQ_API_KEY:", os.getenv("GROQ_API_KEY"))

@app.route("/")
def index():
    return render_template("index.html")

@app.route("/chat", methods=["POST"])
def chat():
    try:
        data   = request.get_json(force=True)
        prompt = data.get("prompt", "").strip()
        if not prompt:
            return jsonify({"response": "No spell detected. Try again."}), 400

        headers = {
            "Authorization": f"Bearer {os.getenv('GROQ_API_KEY')}",
            "Content-Type": "application/json"
        }

        payload = {
            "model": "llama3-70b-8192",
            "messages": [
                {"role": "system",
                 "content": ("You are ArcSyn, a magical AI that helps produce "
                             "music macros, presets, and FX chains. "
                             "Be concise, poetic, and useful.")},
                {"role": "user", "content": prompt}
            ]
        }

        res = requests.post(
            "https://api.groq.com/openai/v1/chat/completions",
            headers=headers,
            json=payload,
            timeout=30
        )
        res.raise_for_status()

        message = res.json()["choices"][0]["message"]["content"]
        return jsonify({"response": message})

    except Exception as e:
        # log the exception and return 500
        print("Error in /chat:", e)
        return jsonify({"response": "💥 The arcane circuit fizzled."}), 500


# ---------- local dev only ----------
if __name__ == "__main__":
    # Render (and most PaaS) sets $PORT.  Default to 5000 for local runs.
    port = int(os.environ.get("PORT", 5000))
    # host 0.0.0.0 so Docker/Render can reach it if you test in containers
    app.run(host="0.0.0.0", port=port, debug=False)
Why this solves the Render 502
Problem	Fix in this file
Flask’s dev server was still launching on Render (blocks gunicorn)	app.run() now runs only when the module is executed directly (python main.py). Gunicorn just imports app.
Render needs the app bound to 0.0.0.0:$PORT	We read os.environ["PORT"] and bind to 0.0.0.0 for local runs; gunicorn already binds correctly in production.
Debug mode in production	debug=False by default.

How to test & deploy
Replace your existing main.py with the code above.

Make sure requirements.txt is in the repo root.

Commit & push:

bash
Copy
Edit
git add main.py requirements.txt
git commit -m "Render-ready main.py (gunicorn friendly)"
git push origin main
In Render → Manual Deploy → Deploy latest commit.
Build log should now find requirements.txt, install packages and start gunicorn:

csharp
Copy
Edit
==> Starting service with 'gunicorn --bind 0.0.0.0:$PORT main:app'
Open the Render URL – you should see your ArcSyn interface instead of “502 Bad Gateway”. 🎉

Let me know if anything else trips you up!